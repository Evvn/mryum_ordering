{"ast":null,"code":"import _regeneratorRuntime from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/michaelfoster/Git/mryum-avc/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/michaelfoster/Git/mryum-avc/src/components/Common/MenuSearch.js\";\nimport React from 'react';\n\nvar MenuSearch =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(MenuSearch, _React$Component);\n\n  function MenuSearch(props) {\n    var _this;\n\n    _classCallCheck(this, MenuSearch);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MenuSearch).call(this, props));\n\n    _this.search =\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(input) {\n        var data, _dataKeys, big_bucket, expression, sectionsPromise, pricePromise, itemNamePromise, itemDescriptionPromise, _ref2, _ref3, sections, price, itemName, itemDesc, actionables;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _this.props.data;\n                _dataKeys = Object.keys(data.menuByItem);\n                big_bucket = [];\n\n                if (!input) {\n                  _context.next = 22;\n                  break;\n                }\n\n                expression = new RegExp(\"\".concat(input), 'gi'); // initial pruning of results\n\n                sectionsPromise = new Promise(function (resolve) {\n                  var bucket = [];\n\n                  for (var _i = 0, _dataKeys2 = _dataKeys; _i < _dataKeys2.length; _i++) {\n                    var key = _dataKeys2[_i];\n                    var fields = data.menuByItem[key].fields;\n\n                    if (expression.test(fields['category'])) {\n                      var _fields = data.menuByItem[key].fields;\n\n                      var searchScore = _this.score(_fields['category'].toString(), expression);\n\n                      bucket.push({\n                        result: _fields['category'],\n                        score: searchScore,\n                        id: _fields.id\n                      });\n                    }\n                  }\n\n                  resolve(bucket);\n                });\n                pricePromise = new Promise(function (resolve) {\n                  var bucket = [];\n                  var expression = new RegExp(\"\".concat(input), 'gi');\n\n                  for (var _i2 = 0, _dataKeys3 = _dataKeys; _i2 < _dataKeys3.length; _i2++) {\n                    var key = _dataKeys3[_i2];\n                    var fields = data.menuByItem[key].fields;\n\n                    if (expression.test(fields['price'])) {\n                      var _fields2 = data.menuByItem[key].fields;\n\n                      var searchScore = _this.score(_fields2['price'].toString(), expression, 'price');\n\n                      bucket.push({\n                        result: _fields2['price'],\n                        score: searchScore,\n                        id: _fields2.id\n                      });\n                    }\n                  }\n\n                  resolve(bucket);\n                });\n                itemNamePromise = new Promise(function (resolve) {\n                  var bucket = [];\n\n                  for (var _i3 = 0, _dataKeys4 = _dataKeys; _i3 < _dataKeys4.length; _i3++) {\n                    var key = _dataKeys4[_i3];\n                    var fields = data.menuByItem[key].fields;\n\n                    if (expression.test(fields['name'])) {\n                      var _fields3 = data.menuByItem[key].fields;\n\n                      var searchScore = _this.score(_fields3['name'].toString(), expression);\n\n                      bucket.push({\n                        result: _fields3['name'],\n                        score: searchScore,\n                        id: _fields3.id\n                      });\n                    }\n                  }\n\n                  resolve(bucket);\n                });\n                itemDescriptionPromise = new Promise(function (resolve) {\n                  var bucket = [];\n\n                  for (var _i4 = 0, _dataKeys5 = _dataKeys; _i4 < _dataKeys5.length; _i4++) {\n                    var key = _dataKeys5[_i4];\n                    var fields = data.menuByItem[key].fields;\n\n                    if (expression.test(fields['description'])) {\n                      var _fields4 = data.menuByItem[key].fields;\n\n                      var searchScore = _this.score(_fields4['description'].toString(), expression);\n\n                      bucket.push({\n                        result: _fields4['description'],\n                        score: searchScore,\n                        id: _fields4.id\n                      });\n                    }\n                  }\n\n                  resolve(bucket);\n                }); // parallel execution\n\n                _context.next = 11;\n                return Promise.all([sectionsPromise, pricePromise, itemNamePromise, itemDescriptionPromise]);\n\n              case 11:\n                _ref2 = _context.sent;\n                _ref3 = _slicedToArray(_ref2, 4);\n                sections = _ref3[0];\n                price = _ref3[1];\n                itemName = _ref3[2];\n                itemDesc = _ref3[3];\n                // concat to one array and sort by match score (highest - lowest)\n                big_bucket = big_bucket.concat(sections, price, itemName, itemDesc);\n                big_bucket.sort(function (a, b) {\n                  return a.score < b.score ? 1 : b.score < a.score ? -1 : 0;\n                }); // prune away scores property from output\n\n                actionables = [];\n                big_bucket.map(function (x) {\n                  return actionables.push(x);\n                });\n                return _context.abrupt(\"return\", actionables);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    _this.score = function (entry, regex, field) {\n      var matched = entry.match(regex);\n\n      if (matched) {\n        var result;\n\n        switch (field) {\n          case 'price':\n            var weight = 0; // weight decimal places and commas(maybe?) higher for prices\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = entry[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var char = _step.value;\n\n                if (char === '.' || char === ',') {\n                  weight += .20;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            result = matched.length / entry.length + weight;\n            break;\n\n          default:\n            result = matched.length / entry.length;\n            break;\n        }\n\n        return result.toFixed(3);\n      }\n    };\n\n    _this.result = [];\n    return _this;\n  }\n\n  _createClass(MenuSearch, [{\n    key: \"render\",\n    value: function render() {\n      var data = this.props.data; // usage example\n\n      this.search('Br').then(function (result) {\n        console.log(result);\n      });\n      return React.createElement(\"div\", {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 128\n        },\n        __self: this\n      }, 'Search');\n    }\n  }]);\n\n  return MenuSearch;\n}(React.Component);\n\nexport default MenuSearch;","map":{"version":3,"sources":["/Users/michaelfoster/Git/mryum-avc/src/components/Common/MenuSearch.js"],"names":["React","MenuSearch","props","search","input","data","_dataKeys","Object","keys","menuByItem","big_bucket","expression","RegExp","sectionsPromise","Promise","resolve","bucket","key","fields","test","searchScore","score","toString","push","result","id","pricePromise","itemNamePromise","itemDescriptionPromise","all","sections","price","itemName","itemDesc","concat","sort","a","b","actionables","map","x","entry","regex","field","matched","match","weight","char","length","toFixed","then","console","log","Component"],"mappings":"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","sourcesContent":["import React from 'react';\n\nclass MenuSearch extends React.Component {\n    constructor(props) {\n        super(props);\n        this.result = [];\n    }\n\n    search = async input => {\n        const {data} = this.props;\n        const _dataKeys = Object.keys(data.menuByItem);\n        let big_bucket = [];\n\n        if (input) {\n            let expression = new RegExp(`${input}`, 'gi');\n            \n            // initial pruning of results\n            let sectionsPromise = new Promise(resolve => {\n                let bucket = [];\n                for (const key of _dataKeys) {\n                    let fields = data.menuByItem[key].fields;\n                    if (expression.test(fields['category'])) {\n                        let fields = data.menuByItem[key].fields;\n                        let searchScore = this.score(fields['category'].toString(), expression);\n                        bucket.push({result: fields['category'], score: searchScore, id: fields.id});\n                    }\n                }\n                \n                resolve(bucket);\n            });\n\n            let pricePromise = new Promise(resolve => {\n                let bucket = [];\n                let expression = new RegExp(`${input}`, 'gi');\n                for (const key of _dataKeys) {\n                    let fields = data.menuByItem[key].fields;\n                    \n                    if (expression.test(fields['price'])) {\n                        let fields = data.menuByItem[key].fields;\n                        let searchScore = this.score(fields['price'].toString(), expression, 'price');\n                        bucket.push({result: fields['price'], score: searchScore, id: fields.id});\n                    }\n                }\n\n                resolve(bucket);\n            });\n\n            let itemNamePromise = new Promise(resolve => {\n                let bucket = [];\n                for (const key of _dataKeys) {\n                    let fields = data.menuByItem[key].fields;\n                \n                    if (expression.test(fields['name'])) {\n                        let fields = data.menuByItem[key].fields;\n                        let searchScore = this.score(fields['name'].toString(), expression);\n                        bucket.push({result: fields['name'], score: searchScore, id: fields.id});\n                    }\n                }\n\n                resolve(bucket);\n            });\n\n            let itemDescriptionPromise = new Promise(resolve => {\n                let bucket = [];\n                for (const key of _dataKeys) {\n                    let fields = data.menuByItem[key].fields;\n                \n                    if (expression.test(fields['description'])) {\n                        let fields = data.menuByItem[key].fields;\n                        let searchScore = this.score(fields['description'].toString(), expression);\n                        bucket.push({result: fields['description'], score: searchScore, id: fields.id});\n                    }\n                }\n\n                resolve(bucket);\n            });\n            \n            // parallel execution\n            let [sections, price, itemName, itemDesc] = await Promise.all([sectionsPromise, pricePromise, itemNamePromise, itemDescriptionPromise]);\n\n            // concat to one array and sort by match score (highest - lowest)\n            big_bucket = big_bucket.concat(sections, price, itemName, itemDesc);\n            big_bucket.sort((a,b) => (a.score < b.score) ? 1 : ((b.score < a.score) ? -1 : 0));\n            \n            // prune away scores property from output\n            let actionables = [];\n            big_bucket.map(x => actionables.push(x));\n            return actionables;\n        }\n    }\n\n\n    score = (entry, regex, field) => {\n        let matched = entry.match(regex);\n        if (matched) {\n            let result;\n            switch (field) {\n                case 'price':\n                    let weight = 0;\n                    // weight decimal places and commas(maybe?) higher for prices\n                    for (let char of entry) {\n                        if (char === '.' || char === ',') {\n                            weight += .20;\n                        }\n                    }\n\n                    result = (matched.length / entry.length) + weight;\n                    break;\n            \n                default:\n                    result = matched.length / entry.length;\n                    break;\n            }\n            return result.toFixed(3);\n        }\n    }\n\n\n    render() {\n        const {data} = this.props;\n\n        // usage example\n        this.search('Br').then(result => {\n            console.log(result)\n        });\n\n        return ( \n            <div> \n                { 'Search' } \n            </div>\n        );\n    }\n}\n\nexport default MenuSearch;"]},"metadata":{},"sourceType":"module"}